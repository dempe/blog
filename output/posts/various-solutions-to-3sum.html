<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <link rel="stylesheet" href="../assets/css/style.css"/>
    <meta name="description"
          content="A personal blog by Chris Dempewolf about science, technology, and computation."/>
    <link rel="stylesheet" href="../assets/css/github-dark.min.css">
    <script src="../assets/js/highlight.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script>hljs.highlightAll();</script>
    <title>Chris Dempewolf's Blog</title>
</head>
<body>
<header>
    <nav>
        <div class="site-title"><a href="../index.html">Chris Dempewolf</a></div>
        <div class="nav-flex-container">
            <menu>
                <li><a href="../about.html">About</a></li>
                
                <li><a href="../resume.pdf" target="_blank">Resume</a></li>
                <li><a href="../tags/index.html">Tags</a></li>
            </menu>
        </div>
    </nav>
</header>
<main>
    <article>
        <h1 id="title">    Various Solutions to 3SUM
</h1>
            <table class="post-metadata">
        <tr>
            <td class="table-key">Published:&nbsp;&nbsp;</td>
            <td>2024-03-03 06:41</td>
        </tr>
        <tr>
            <td class="table-key">Updated:&nbsp;&nbsp;</td>
            <td>
                                    2024-03-03 19:23
                            </td>
        </tr>
        <tr>
            <td class="table-key">Tags:&nbsp;&nbsp;</td>
            <td>
                                    <a href="../tags/algorithms.html">algorithms</a>&nbsp;
                                    <a href="../tags/java.html">java</a>&nbsp;
                                    <a href="../tags/tech.html">tech</a>&nbsp;
                            </td>
        </tr>
    </table>
                        <p>I've seen three different variations of the 3SUM problem.  In order of increasing complexity:</p>
<p>Given an array of integers,</p>
<ol>
<li>Do <strong>any</strong> three sum to zero?</li>
<li><strong>How many</strong> triplets sum to zero?</li>
<li><strong>Which</strong> distinct triplets sum to zero?</li>
</ol>
<p>Let's solve #3.</p>
<p>First, let's be more precise.  LeetCode defines the problem thus:</p>
<blockquote>
<p>Given an integer array <code>nums</code>, return all triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p>
</blockquote>
<h2 id='brute-force'>Brute Force</h2>
<p>For the brute force solution, just loop over the array checking each triplet. If a triplet sums to 0, add it to our set (we're using a set to prevent adding duplicate triplets).  Start <code>j</code> at <code>i + 1</code> and <code>k</code> at <code>j + 1</code> to avoid looking at indices more than once.</p>
<ul>
<li><strong>Time complexity</strong>: $O(n^3)$</li>
<li><strong>Space complexity</strong>: $O(1)$</li>
</ul>
<pre><code class="language-java">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        // First, sort the array so that the triplets will also be sorted.
        // This ensures that the hash set will reject any non-distinct triplets.
        Arrays.sort(nums);
        final Set&lt;List&lt;Integer&gt;&gt; results = new HashSet&lt;&gt;();

        for (int i = 0; i &lt; nums.length; i++) {
            for (int j = i + 1; j &lt; nums.length; j++) {
                for (int k = j + 1; k &lt; nums.length; k++) {
                    final int ival = nums[i];
                    final int jval = nums[j];
                    final int kval = nums[k];

                    if (ival + jval + kval != 0) { continue; }

                    results.add(Arrays.asList(ival, jval, kval));
                }
            }
        }

        return new ArrayList&lt;&gt;(results);
    }</code></pre>
<h2 id='hashmap'>Hashmap</h2>
<p>Here, we loop through the <code>nums</code> array and make a map of values to all indices they appear in. We have the two <code>i</code> and <code>j</code> loops as before, but we can (mostly) skip the <code>k</code> loop.</p>
<p>Since we already have two values (<code>ival</code> and <code>jval</code>), we can simply compute the difference <code>(ival + jval) * -1</code> and check if it's in the hashmap. Since the hashmap will return a list of values, we will need to have a third loop.</p>
<ul>
<li><strong>Time complexity</strong>: $O(n^3)$</li>
<li><strong>Space complexity</strong>: $O(n)$</li>
</ul>
<p>Note that the worst case time complexity is no better than brute force.  And with worse space complexity! The difference is that the brute force algorithm <em>always</em> runs in $O(n^3)$. For &quot;reasonable&quot; inputs, the amortized time complexity of the hashmap version is much better.</p>
<pre><code class="language-java">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        Arrays.sort(nums);
        final Set&lt;List&lt;Integer&gt;&gt; results = new HashSet&lt;&gt;();
        final Map&lt;Integer, List&lt;Integer&gt;&gt; valuesToIndices = new HashMap&lt;&gt;();

        for (int i = 0; i &lt; nums.length; i++) {
            valuesToIndices.putIfAbsent(nums[i], new ArrayList&lt;&gt;());
            valuesToIndices.get(nums[i]).add(i);
        }

        for (int i = 0; i &lt; nums.length; i++) {
            for (int j = i + 1; j &lt; nums.length; j++) {
                final int ival = nums[i];
                final int jval = nums[j];
                final int kval = (ival + jval) * -1;
                final List&lt;Integer&gt; candidates = valuesToIndices.getOrDefault(kval, null);

                // candidates should never be empty, but check just in case.
                if (candidates == null || candidates.isEmpty()) { continue; } // Not found

                for (final int k : candidates) {
                    if (k &lt;= j) { continue; }
                    results.add(Arrays.asList(ival, jval, kval));
                    break;
                }
            }
        }

        return new ArrayList&lt;&gt;(results);
    }</code></pre>
<h2 id='binary-search'>Binary Search</h2>
<p>This is similar to the hashmap version, but instead of looking up the values in a hashmap, we binary search the input array (that we should have already sorted). Again, we calculate the difference between <code>i + j</code> and 0 (<code>(nums[i] + nums[j]) * -1</code>).</p>
<p>The outer two loops run in $n^2$ time.  Binary search takes $\log n$ time. Multiplying these together,</p>
<ul>
<li><strong>Time complexity</strong>: $O(n^2{\log n})$</li>
<li><strong>Space complexity</strong>: $O(1)$</li>
</ul>
<pre><code class="language-java">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        Arrays.sort(nums);
        final Set&lt;List&lt;Integer&gt;&gt; results = new HashSet&lt;&gt;();

        for (int i = 0; i &lt; nums.length; i++) {
            for (int j = i + 1; j &lt; nums.length; j++) {
                final int ival = nums[i];
                final int jval = nums[j];
                final int kval = (ival + jval) * -1;

                int k = Arrays.binarySearch(nums, kval);

                if (k &lt; 0) { continue; }    // Not found             
                if (k &lt;= j ) { k = j + 1; } // If k is less than or equal to j, we have already processed this index.
                if (k &gt;= nums.length || nums[k] != kval) { continue; }

                results.add(Arrays.asList(ival, jval, kval));
            }
        }

        return new ArrayList&lt;&gt;(results);
    }</code></pre>
<h2 id='quadratic-algorithm'>Quadratic Algorithm</h2>
<p>The quadratic algorithm takes a completely different approach.  For each element of the array, we create two pointers that point the first and last elements of the remaining elements.  In the inner loop, we increment the start pointer and decrement the end pointer if a triplet sums to zero.</p>
<p>If the sum is less than zero, we know we need to increment the start pointer. The array is sorted, so the only way to get a larger sum is to increment the lower pointer. Likewise, if the sum is greater than zero, we need to decrement the end pointer to try to find a lower value.</p>
<ul>
<li><strong>Time complexity</strong>: $O(n^2)$</li>
<li><strong>Space complexity</strong>: $O(1)$</li>
</ul>
<pre><code class="language-java">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        Arrays.sort(nums);
        final List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;();

        for (int i = 0; i &lt; nums.length - 2; i++) {
            final int ival = nums[i];
            int start = i + 1;
            int end = nums.length - 1;

            while (start &lt; end) {
                final int jval = nums[start];
                final int kval = nums[end];

                if (ival + jval + kval == 0) {
                    results.add(Arrays.asList(ival, jval, kval));
                    start++;
                    end--;
                }
                else if (ival + jval + kval &gt; 0) {
                    end--;
                }
                else {
                    start++;
                }
            }
        }

        return results;
    }</code></pre>
    </article>
</main>
<footer>
        <nav id="footer-nav">
        <div id="prev-post-link">
                            <span>⬅️ <a href="converting-kindle-notes-to-markdown.html">Converting Kindle Notes to Markdown</a></span>
                    </div>
        <div id="next-post-link">
                            <span><a href="a-wizards-existential-crisis.html">A Wizard&#039;s Existential Crisis</a> ➡️</span>
                    </div>
    </nav>
</footer>
    
    
    
    

    
    
    
    
    
    
    
    
    
    
</body>
</html>

